/*
 * Copyright (C) 2025 Tony Luken <tonyluken62+gerberfilereader.gmail.com>
 * 
 * This file is part of gerberFileReader.
 * 
 * gerberFileReader is free software: you can redistribute it and/or modify it under the terms of 
 * the GNU General Public License as published by the Free Software Foundation, either version 3 of 
 * the License, or (at your option) any later version.
 * 
 * gerberFileReader is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with gerberFileReader. If
 * not, see <http://www.gnu.org/licenses/>.
 */

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.io.File;
import javax.imageio.ImageIO;
import org.junit.jupiter.api.Test;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.Rect;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;

import gerberFileReader.GerberFileReader;
import gerberFileReader.GraphicalObject;
import gerberFileReader.GraphicsStream;
import gerberFileReader.Polarity;
import standardAttributes.FileMD5;

public class ImageGenerationTest {
    static {
        //We use OpenCV to only find and compare the objects in the test images with the expected 
        //images 
        nu.pattern.OpenCV.loadLocally();
    }

    private final static boolean DEBUG = false; //Set to true to save problem images to the temp dir
    private final static double ASPECT_RATIO_TOLERANCE = 0.0025;
    private final static int EROSION_KERNEL_SIZE = 7; //needs to be an odd positive integer
    private Exception savedError = null;
    
    /**
     * This test generates images from a set of Gerber files and compares them to screen captures of
     * images generated by Ucamco's web based Reference Gerber Viewer.
     * 
     * @throws Exception if there is a problem reading the files or if the images miscompare.
     */
    @Test
    public void testImageGeneration() throws Exception {
        for (int round=0; round<2; round++) {
            File testFileDir = new File(ClassLoader.getSystemResource("gerberFiles").getPath());
            File expectedDir = new File(ClassLoader.getSystemResource("expectedResults").getPath());
            if (round>0) {
                testFileDir = new File(testFileDir.getPath() + File.separator + "sampleBoardDesign");
                expectedDir = new File(expectedDir.getPath() + File.separator + "sampleBoardDesign");
            }
            File[] files = testFileDir.listFiles();
            for (File testFile : files) {
                if (testFile.isDirectory()) {
                    continue;
                }
                System.out.println(testFile);
                String expectedName = testFile.getName().substring(0, testFile.getName().length()-3) + "png";
                File expectedFile = new File(expectedDir + File.separator + expectedName);
                if (!testFile.exists() || !expectedFile.exists()) {
                    continue;
                }
                
                //Create a GerberFileReader for the testFile and start parsing the file in the 
                //background. Normally if this is being done in a GUI, the showProgress and 
                //runOnSuccess parameters to parseFileInBackground would be used to update the GUI.
                //But since we're just running a test here without a GUI, we'll just set both of 
                //those parameters to null and use a loop to pause execution of the current task
                //until the parsing is done.
                GerberFileReader parser = new GerberFileReader(testFile);
                parser.parseFileInBackground(null, null, (ex)->savedError=ex);
                
                //Read in the expected image while the Gerber file is being parsed
                System.out.println(expectedFile);
                BufferedImage expectedImage = ImageIO.read(expectedFile);
                Mat expectedImageMat = bufferedImageToMat(expectedImage);
                
                //Get the bounding box of the objects in the expected image
                Rect bbExpected = Imgproc.boundingRect(expectedImageMat);
    
                //Wait for the parser to finish
                while (!parser.isDone() && !parser.isError()) {
                    //spin until the parser is either done or errors out
                    Thread.onSpinWait();
                };
                
                //Check to see if the parser had any errors
                if (parser.isError()) {
                    savedError.printStackTrace();
                    throw new Exception(savedError.getMessage());
                }
                
                //Attempt to get the .MD5 Standard Attribute from the file attributes
                FileMD5 expectedMD5 = parser.getFileAttributes().get(new FileMD5());
                
                //Attempt to get the file's actual MD5 signature from the parser
                String actualSignature = parser.getActualMD5Signature();
                
                //If we have both, we can compare them to see if the file has been unexpectedly 
                //altered
                if (expectedMD5 != null && actualSignature != null) {
                    System.out.println("Checking MD5 signature...");
                    if (!actualSignature.equals(expectedMD5.getSignature())) {
                        throw new Exception("File may be corrupted, actual MD5 signature (" + 
                                actualSignature + ") does not match expected (" + 
                                expectedMD5.getSignature());
                    }
                    System.out.println("MD5 signature Ok!");
                }
                
                //Render an image based on the results of parsing the Gerber file
                BufferedImage gerberImage = renderGerberImage(parser.getGraphicsStream(), 
                        expectedImageMat.size(), bbExpected);
                Mat gerberImageMat = bufferedImageToMat(gerberImage);
                
                //Get the bounding box of all objects in the Gerber image
                Rectangle2D bbTest = parser.getGraphicsStream().getBounds();
                
                //Check to make sure the aspect ratios of the objects in the expected image and the test
                //image are nearly the same
                double aspectRatioRatio = bbExpected.width*bbTest.getHeight()/(bbExpected.height*bbTest.getWidth());
                if (Math.abs(aspectRatioRatio - 1) > ASPECT_RATIO_TOLERANCE) {
                    if (DEBUG) {
                        //Save the images in the system's default temp directory for later analysis
                        String tempDirName = System.getProperty("java.io.tmpdir");
                        File outFile = new File(tempDirName + File.separator + "expectedImage.png");
                        ImageIO.write(expectedImage, "png", outFile);
                        outFile = new File(tempDirName + File.separator + "testImage.png");
                        ImageIO.write(gerberImage, "png", outFile);
                    }
                    throw new Exception("Aspect ratios are too different: " + Math.abs(aspectRatioRatio - 1));
                }
                
                //Generate a binary image that has pixels set wherever the two images differ
                Mat comparisonImageMat = new Mat();
                Core.bitwise_xor(expectedImageMat, gerberImageMat, comparisonImageMat);
                
                //Since the expected image is a screen capture from a web page, it probably has a 
                //different resolution/anti-aliasing than the image generated by renderGerberImage. 
                //Therefore we can't expect the two images to be exactly the same. So for comparison 
                //purposes, we need to ignore any small differences that occur around the edges of 
                //objects. We do that by eroding the difference image by a few pixels.
                Mat erodedImageMat = new Mat();
                Mat element = Imgproc.getStructuringElement(Imgproc.CV_SHAPE_RECT, 
                        new Size(EROSION_KERNEL_SIZE, EROSION_KERNEL_SIZE));
                Imgproc.erode(comparisonImageMat, erodedImageMat, element);
                
                //Finally we count all the remaining non-zero pixels to determine if the images are
                //really different
                int differentPixelCount = Core.countNonZero(erodedImageMat);
    
                if (differentPixelCount > 0) {
                    if (DEBUG) {
                        //Save the images in the system's default temp directory for later analysis
                        String tempDirName = System.getProperty("java.io.tmpdir");
                        File outFile = new File(tempDirName + File.separator + "expectedImage.png");
                        ImageIO.write(expectedImage, "png", outFile);
                        outFile = new File(tempDirName + File.separator + "testImage.png");
                        ImageIO.write(gerberImage, "png", outFile);
                        outFile = new File(tempDirName + File.separator + "comparisonImage.png");
                        ImageIO.write(matToBufferedImage(comparisonImageMat), "png", outFile);
                        outFile = new File(tempDirName + File.separator + "erodedImage.png");
                        ImageIO.write(matToBufferedImage(erodedImageMat), "png", outFile);
                    }
                    throw new Exception("The test and expected images failed to compare, number of different pixels = " + differentPixelCount);
                }
                else {
                    System.out.println("The test and expected images compared successfully");
                }
                
                //Clean-up
                expectedImageMat.release();
                gerberImageMat.release();
                comparisonImageMat.release();
                erodedImageMat.release();
                
            }
        }
        System.out.println("All images compared successfully!");
    }
    
    /**
     * Converts a BufferedImage to a binary OpenCV image
     * @param bi - the BufferedImage to convert
     * @return the binary OpenCV image
     */
    private static Mat bufferedImageToMat(BufferedImage bi) {
        Mat mat = new Mat(bi.getHeight(), bi.getWidth(), CvType.CV_8UC3);
        byte[] data = ((DataBufferByte) bi.getRaster().getDataBuffer()).getData();
        mat.put(0, 0, data);
        Imgproc.cvtColor(mat, mat, Imgproc.COLOR_RGB2GRAY);
        Imgproc.threshold(mat, mat, 100, 255, Imgproc.THRESH_BINARY);
        return mat;
    }
    
    /**
     * Converts an OpenCV image to a gray scale BufferedImage
     * @param mat - the OpenCV image to convert
     * @return the gray scale BufferedImage
     */
    private static BufferedImage matToBufferedImage(Mat mat) {
        BufferedImage gray = new BufferedImage(mat.width(), mat.height(), BufferedImage.TYPE_BYTE_GRAY);
        byte[] data = ((DataBufferByte) gray.getRaster().getDataBuffer()).getData();
        mat.get(0, 0, data);
        return gray;
    }
    
    /**
     * Renders a Gerber image so that the objects are scaled and located within the image so as to 
     * have the same size and location as those in an expected image.  
     * @param gs - the GraphicsStream from a gerberFileReader
     * @param imageSize - the size of the image to produce (should be the same as the expected
     * image)
     * @param bbTo - the bounding box of the objects in the expected image
     * @return the Gerber image
     */
    private static BufferedImage renderGerberImage(GraphicsStream gs, Size imageSize, Rect bbTo) throws Exception {
        //Get the bounding box of all objects in the Gerber image
        Rectangle2D bbFrom = gs.getBounds();
        
        //Create the test image with the same size as the expected image
        BufferedImage gerberImage = new BufferedImage((int) imageSize.width, 
                (int) imageSize.height, BufferedImage.TYPE_3BYTE_BGR);
        Graphics2D offScr = (Graphics2D) gerberImage.getGraphics();
        offScr.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        Color background = Color.BLACK;
        Color foreground = Color.WHITE;
        
        //Fill the entire image with the background color
        offScr.setColor(background);
        offScr.fillRect(0, 0, (int) imageSize.width, (int) imageSize.height);
        
        //Set the translation and scaling so that when the Gerber objects get plotted onto the test 
        //image, they fall at the same pixel coordinates as the objects in the expected image. Note
        //that Gerber objects follow the Gerber convention of the X-axis increasing to the right and 
        //the Y-axis increasing upwards while the Java standard for images has the X-axis increasing
        //to the right and the Y-axis increasing downwards. So the translation and scaling we need 
        //maps the lower left corner of the Gerber objects' bounding box [bbFrom.x, bbFrom.y] to the
        //lower left corner of the expected image objects' bounding box [bbTo.x, bbTo.y+bbTo.height]
        //and the upper right corner of the Gerber objects' bounding box [bbFrom.x+bbFrom.width, 
        //bbFrom.y+bbFrom.height] to the upper right corner of the expected image objects' bounding 
        //box [bbTo.x+bbTo.width, bbTo.y]. This gives us two sets (one for X and one for Y) of two 
        //(one for the LL corner and one for the UR corner) simultaneous equations of the form 
        //bbTo = m*bbFrom + b where m is the scale factor and b is the translation. Solving these
        //two sets of two simultaneous equations results in the following:
        offScr.translate(bbTo.x - bbFrom.getX()*bbTo.width/bbFrom.getWidth(), 
                bbTo.y + bbTo.height + bbFrom.getY()*bbTo.height/bbFrom.getHeight());
        offScr.scale(bbTo.width/bbFrom.getWidth(), -bbTo.height/bbFrom.getHeight());
        
        //Plot all the Gerber graphical objects onto the image plane in the order they appear in the
        //graphics stream
        for (GraphicalObject go : gs.getStream()) {
            if (go.getPolarity() == Polarity.DARK) {
                //Polarity Dark means the object will plot on top of anything already plotted and
                //cover-up everything behind it
                offScr.setColor(foreground);
            }
            else { //Polarity.Clear
                //Polarity Clear means the object will erase everything behind it (except of course 
                //the backgound)
                offScr.setColor(background);
            }
            
            offScr.fill(go.getArea());
        }
        
        offScr.dispose();
        
        return gerberImage;
    }
}
